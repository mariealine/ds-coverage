/**
 * Template: UI Component Creation Standards
 *
 * Generates a markdown rule for how to create new UI components
 * following design system patterns.
 */

import type { DsCoverageConfig } from "../config.js";

export function generateComponentRule(config: DsCoverageConfig): string {
  const api = config.componentAnalysis.api;
  const primaryDir = config.componentAnalysis.primaryDirectory;

  const sizeVariants = api.expectedSizes
    .map((s) => `        ${s}: "",`)
    .join("\n");

  const sizeList = api.expectedSizes
    .map((size) => `  - \`${size}\``)
    .join("\n");

  const forbiddenSizeNote = api.forbiddenSizes.length > 0
    ? `\n\n**Forbidden** (legacy abbreviations): ${api.forbiddenSizes.map((s) => `\`${s}\``).join(", ")}`
    : "";

  return `# UI Component Creation Standards

## Applies to
Files in \`${primaryDir}\`.

## Rule

Every UI component MUST follow the design system architecture. UI components are the **atomic building blocks** — they must be generic, reusable, and design-system compliant.

> **This rule is auto-generated by ds-coverage.** Update your \`ds-coverage.config\` and re-run \`npx ds-coverage init\` to regenerate.

---

## Component location

**All reusable components live in a single folder:**

\`\`\`
${primaryDir}    ← ALL design system components
\`\`\`
${config.componentAnalysis.legacyDirectories.length > 0 ? `\n> **Note:** Legacy components may exist in ${config.componentAnalysis.legacyDirectories.map((d) => `\`${d}\``).join(", ")}. When editing these, flag them for migration to \`${primaryDir}\` with \`@ds-migrate: complex\` if appropriate. New components MUST always go in \`${primaryDir}\`.\n` : ""}
---

## Creating a new UI component

### 1. Naming
- **Simple and concise**: \`Badge\`, \`Card\`, \`Toggle\` — not \`StatusIndicatorBadge\`
- **One word when possible**, two words max
- **No parent-child naming**: Every component is standalone
- **File name** matches component name: \`badge.tsx\` → \`Badge\`

### 2. Architecture pattern (CVA${api.requireRadix ? " + Radix" : ""})

\`\`\`tsx
import { cva, type VariantProps } from "class-variance-authority";${api.requireRadix ? '\nimport { Slot } from "radix-ui";' : ""}

const componentVariants = cva(
  // Base classes — semantic tokens only
  "relative flex items-center",
  {
    variants: {${api.expectedProps.includes("appearance") ? `
      appearance: {
        accent: "",
        danger: "",
      },` : ""}${api.expectedProps.includes("hierarchy") ? `
      hierarchy: {
        primary: "",
        secondary: "",
        tertiary: "",
      },` : ""}${api.expectedProps.includes("size") ? `
      size: {
${sizeVariants}
      },` : ""}
    },${api.expectedProps.includes("appearance") && api.expectedProps.includes("hierarchy") ? `
    // compoundVariants combine appearance × hierarchy for final styles
    compoundVariants: [
      {
        appearance: "accent",
        hierarchy: "primary",
        class: "bg-brand-primary text-complementary",
      },
      // ... more combinations
    ],` : ""}
  },
);

function MyComponent({
  className,${api.expectedProps.includes("appearance") ? '\n  appearance = "accent",' : ""}${api.expectedProps.includes("hierarchy") ? '\n  hierarchy = "secondary",' : ""}${api.expectedProps.includes("size") ? '\n  size = "default",' : ""}${api.requireRadix ? "\n  asChild = false," : ""}
  ...props
}: ComponentProps & VariantProps<typeof componentVariants>) {${api.requireRadix ? '\n  const Comp = asChild ? Slot : "div";' : ""}
  return (
    <${api.requireRadix ? "Comp" : "div"}
      className={cn(componentVariants({ ${api.expectedProps.join(", ")} }), className)}
      {...props}
    />
  );
}
\`\`\`

### Key patterns:
${api.expectedProps.includes("appearance") && api.expectedProps.includes("hierarchy") ? "1. **`appearance` × `hierarchy` via `compoundVariants`**: Combine them for precise control per combination" : "1. **Use CVA variants** for all visual variations"}
2. **Default values in function signature**, not in CVA
3. **Always accept \`className\`** for composition
${api.requireRadix ? "4. **Support `asChild`** when wrapping Radix primitives\n" : ""}
### 3. Design token compliance

- **ALL colors**: Must use semantic tokens — zero hardcoded palette classes
- **ALL radius**: Must use token values
- **ALL text styles**: Must use unified typescale classes — do NOT combine \`text-*\` and \`font-*\` separately
- **NO** hardcoded colors, hex values, or raw utility classes for visual properties

### 4. API design — prop names

Use these **standardized prop names** across all components:
${api.expectedProps.map((p) => `- **\`${p}\`**`).join("\n")}
- **\`className\`** — always accepted for composition
- **\`disabled\`** — for interactive components

**\`size\` values** (full words only):
${sizeList}${forbiddenSizeNote}

${api.forbiddenProps.length > 0 ? `**Forbidden prop names** (legacy — must be migrated):\n${api.forbiddenProps.map((p) => `- \`${p}\``).join("\n")}` : ""}

### 5. Accessibility

- Use \`focus-visible\` (not \`focus\`) for keyboard-only focus rings
- Include proper ARIA attributes
- Disabled states: both visual and functional (\`pointer-events-none\`)

### 6. Checklist before merging a new UI component

- [ ] Uses CVA for variants
- [ ] All visual properties use semantic tokens (zero hardcoded values)
- [ ] Has \`className\` prop for composition
- [ ] Naming is simple and concise (1-2 words)
- [ ] API is consistent with existing components (${api.expectedProps.join(", ")})
- [ ] Focus-visible states defined
- [ ] Disabled states defined (if interactive)
${api.requireRadix ? "- [ ] Supports `asChild` via Radix Slot\n" : ""}`;
}
