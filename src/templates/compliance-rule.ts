/**
 * Template: Design System Compliance Rule
 *
 * Generates a markdown rule file for AI assistants (Cursor, Claude, Agents)
 * based on the ds-coverage config. This ensures the AI enforces the same
 * rules the scanner detects.
 */

import type { DsCoverageConfig } from "../config.js";

export function generateComplianceRule(config: DsCoverageConfig): string {
  const api = config.componentAnalysis.api;
  const primaryDir = config.componentAnalysis.primaryDirectory;
  const legacyDirs = config.componentAnalysis.legacyDirectories;

  // Build violation checklist from config
  const violationChecklist = Object.entries(config.violations)
    .filter(([, v]) => v.enabled)
    .map(([key, v]) => {
      const examples = getViolationExamples(key);
      return `- **${v.label}** ${v.icon} — ${examples.forbidden}. ${examples.instruction}`;
    })
    .join("\n");

  // Build size table — expected values + forbidden values listed separately
  const sizeTable = api.expectedSizes
    .map((size) => `| \`${size}\` |`)
    .join("\n");

  const forbiddenSizesList = api.forbiddenSizes.length > 0
    ? api.forbiddenSizes.map((s) => `\`${s}\``).join(", ")
    : "";

  // Build prop naming table
  const forbiddenPropsNote = api.forbiddenProps.length > 0
    ? `\n\n**Forbidden prop names** (legacy): ${api.forbiddenProps.map((p) => `\`${p}\``).join(", ")}. These must be migrated to the correct names above.`
    : "";

  return `# Design System Compliance Protocol

## Applies to
All frontend work in \`${config.scanDir}/\`.

## Rule

This rule defines the **decision framework** for building UI. It ensures design consistency through component reuse, systematic flagging, and incremental refactoring.

> **This rule is auto-generated by ds-coverage.** It stays in sync with the scanner config so AI assistants enforce the same rules the scanner detects.

---

## CRITICAL — New code requirements

**Every line of new frontend code MUST be design-system compliant from the start.** This is not optional — there is zero tolerance for introducing new design debt.

Before writing ANY UI code, check:
${violationChecklist}
- **Components** → Does a component already exist in \`${primaryDir}\`? **Use it.** ${legacyDirs.length > 0 ? `Also check legacy directories (${legacyDirs.map((d) => `\`${d}\``).join(", ")}) — but new components MUST go in \`${primaryDir}\`.` : ""}

**If this rule is not followed, the code must be rejected.**

---

## Decision hierarchy (follow in order)

### 1. Use an existing UI component
Check \`${primaryDir}\` first. If a component exists that matches your need, **use it**. Do not recreate buttons, badges, inputs, dialogs, selects, etc.
${legacyDirs.length > 0 ? `\n> **Note:** Some components still live in legacy directories (${legacyDirs.map((d) => `\`${d}\``).join(", ")}). Check there too, but new components always go in \`${primaryDir}\`.` : ""}

### 2. Create a new UI component
If no existing component fits, create one in \`${primaryDir}\`. The component MUST:
- Use CVA for variants
- Use semantic design tokens exclusively
- Have a simple, concise name (1-2 words)
- Follow the prop naming conventions below

### 3. Last resort: inline code with tokens
If you need a one-off layout that doesn't warrant a component, you may write inline CSS/utility classes — but you MUST use semantic tokens. Flag it if the pattern might be reusable:

\`\`\`tsx
// @ds-todo: Consider creating a <StatusDot> component if this pattern repeats
<span className="inline-block size-2 rounded-full bg-success-primary" />
\`\`\`

---

## Prop naming conventions

All design system components use these **standardized prop names**:

### Expected variant props: ${api.expectedProps.map((p) => `\`${p}\``).join(", ")}${forbiddenPropsNote}

### \`size\` prop — full words only
| Accepted values |
|-----------------|
${sizeTable}
${forbiddenSizesList ? `\n**Forbidden** (legacy abbreviations): ${forbiddenSizesList}` : ""}

${api.legacyVariantValues.length > 0 ? `### Legacy variant values to migrate\n${api.legacyVariantValues.map((v) => `- \`${v}\` → use the appropriate semantic equivalent`).join("\n")}` : ""}

---

## Flagging conventions

Three types of flags to annotate code:

### \`@ds-migrate: simple\`
A straightforward swap. Can be done inline by any developer or AI assistant.

\`\`\`tsx
// @ds-migrate: simple | Replace hardcoded color with semantic token
\`\`\`

### \`@ds-migrate: complex\`
A migration that requires dedicated effort. Include: what to migrate, risks, cost estimate, and constraints.

\`\`\`tsx
// @ds-migrate: complex | This custom dropdown should use <Select> from UI kit.
// Risks: Custom keyboard navigation logic may conflict.
// Cost: ~2h refactor, need to verify all usages.
\`\`\`

### \`@ds-todo\`
A missing component or token that should be added to the design system.

\`\`\`tsx
// @ds-todo: Create <Chip> component — used here and in 3 other places for removable filter tags
\`\`\`

---

## Boy Scout Rule protocol

When editing any file in \`${config.scanDir}/\`:

1. **Scan the code you touch** (the function, the component, the block you're modifying)
2. **Apply unambiguous migrations immediately**: 1:1 token swaps that have a clear semantic match
3. **When multiple semantic tokens could match**, **suggest the options to the developer** with context explaining the semantic meaning of each candidate. Provide visual context when possible:
   - **(a) Take a screenshot** via browser tools if available
   - **(b) Ask the developer for a screenshot**, providing the navigation path
   - **(c) Describe visually** what the component looks like as a last resort
4. **Flag complex migrations**: Don't silently refactor large patterns — add \`@ds-migrate: complex\`
5. **Flag missing components**: If you spot a repeated pattern, add \`@ds-todo\`
6. **Never break existing behavior**: Migrations must be visual-only. Same look, same interactions.

---

## What counts as "non-compliant"

Any of these in code you're editing should be flagged or fixed:

${Object.entries(config.violations)
    .filter(([, v]) => v.enabled)
    .map(([key, v]) => `- ${v.icon} **${v.label}**: ${getViolationDescription(key)}`)
    .join("\n")}
- Hardcoded \`<button>\`, \`<input>\`, \`<select>\` when a UI component exists
- Duplicated UI patterns that should be a component
${api.forbiddenProps.length > 0 ? api.forbiddenProps.map((p) => `- Legacy prop name \`${p}\``).join("\n") : ""}
${api.forbiddenSizes.length > 0 ? `- Legacy size values: ${api.forbiddenSizes.map((s) => `\`${s}\``).join(", ")}` : ""}

---

## Refactoring workflow

For dedicated refactoring sessions:

1. **Find flags**: Search codebase for \`@ds-migrate\` and \`@ds-todo\` comments
2. **Run the scanner**: \`npx ds-coverage\` — open the dashboard to see violations
3. **Prioritize**:
   - \`@ds-migrate: simple\` → batch and apply (quick wins)
   - \`@ds-todo\` → create missing DS components
   - \`@ds-migrate: complex\` → plan as dedicated tasks
4. **Verify**: After migration, test visually
5. **Clean up**: Remove the flag comment after the migration is done
6. **Re-scan**: Run \`npx ds-coverage\` again to verify improvements
`;
}

function getViolationExamples(key: string): { forbidden: string; instruction: string } {
  const examples: Record<string, { forbidden: string; instruction: string }> = {
    hardcodedColors: {
      forbidden: "**NEVER** use `text-gray-*`, `bg-blue-*`, `border-red-*`, `text-white`, `bg-white`",
      instruction: "Use semantic color tokens instead.",
    },
    hardcodedTypography: {
      forbidden: "**NEVER** combine `text-sm` + `font-medium` separately",
      instruction: "Use unified typescale classes (e.g. `typescale-default-medium`).",
    },
    hardcodedRadius: {
      forbidden: "**NEVER** use `rounded-sm`, `rounded-md`, `rounded-lg`",
      instruction: "Use numeric radius tokens (e.g. `rounded-4`, `rounded-8`).",
    },
    hardcodedShadows: {
      forbidden: "**NEVER** use `shadow-sm`, `shadow-md`, `shadow-lg`",
      instruction: "Use named shadow tokens instead.",
    },
    darkMode: {
      forbidden: "**NEVER** use `dark:` prefix",
      instruction: "Dark mode is handled via semantic tokens — no `dark:` classes needed.",
    },
  };
  return examples[key] || {
    forbidden: "Avoid hardcoded values",
    instruction: "Use semantic design tokens instead.",
  };
}

function getViolationDescription(key: string): string {
  const descriptions: Record<string, string> = {
    hardcodedColors: "Raw color palette classes (`text-gray-*`, `bg-blue-*`, `border-red-*`, `text-white`, `bg-white`)",
    hardcodedTypography: "Raw font size/weight classes (`text-sm`, `font-medium`, `text-xl font-bold`)",
    hardcodedRadius: "Hardcoded border-radius (`rounded-lg`, `rounded-xl`, `rounded-2xl`)",
    hardcodedShadows: "Hardcoded shadows (`shadow-sm`, `shadow-lg`, `shadow-inner`)",
    darkMode: "`dark:` prefixed classes (`dark:bg-gray-900`, `dark:text-white`)",
  };
  return descriptions[key] || "Hardcoded values detected by the scanner";
}
